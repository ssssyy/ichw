# 第一个问题
~~（此处为copy知乎上的定义）~~停机问题表述如下：**不存在**一个算法，能够判断任意图灵机Μ在任意字符串ω上是否停机。
所以，在我理解中图灵证明停机问题是为了找到一个使图灵机不停机的输入以避免停机，而停机问题便是说明这样一个能判断**任意给定输入**对**给定图灵机**是否会导致停机的**算法**是**不存在的**

证明方法：反证法和悖论法：假设存在，构造这样一个算法使得其可以证明停机问题，则连续使用两次该算法函数后出现悖论：若机器发现该输入将导致停机则其执行不停机操作，若机器发现该算法不停机则执行停机操作，这样一个停机（不停机）的**输入**将产生不停机（停机）的**结果**。故证明了这样一个算法必定是不存在的。
  
数学原理：~~（这个我也不知道啊，只能脑补一下）~~不自洽性

# 第二个问题
  二进制补码是是计算机储存二进制数的一种方法，即正数的补码为本身，负数的补码为原码取反码（除最高位用于表示符号）后加1，也可为从右至左依次照写，直到遇到第一个1时将该位及其左边的每一位都取其反码即可得到负数的补码。
  
   计算机系统中，若要计算减法常化为加法，而上述求补码的两种方法实际上都求得了该二进制数在2的n次幂的模下的补数，故减去原数在模的作用下舍去溢出部分后完全等价于加上原数的补码。
   
   原理上的话，这本身就是个天才的算法，类似于顺时针逆时针拨动时钟，+1与-11是等价的（假设只有一根指针），而补码的算法就恰好使得补码与原码构成了类似+1与-11的关系。
   
# 第三个问题
0：0000000000000000

-0:1000000000000000

1.0：0011111100000000

-1.0:1011111100000000

最大非规范数：0000000011111111

最小非规范数：1000000011111111

最小规范数：1111111011111111

最大规范数：0111111011111111

+∞：0111111100000000

-∞：1111111100000000

NaN：0111111100000001（这个有太多表示了，此处仅给出一种）
